# Schema based on the provided blueprint for WAF and resource management.

# Represents a subscription, which can contain multiple resource groups.
type AppSubscription @table(key: "SubscriptionID") {
  SubscriptionID: UUID! @default(expr: "uuidV4()")
  SubscriptionName: String!
}

# Represents a resource group, which contains resources.
type ResourceGroup @table(key: "ResourceGroupID") {
  ResourceGroupID: UUID! @default(expr: "uuidV4()")
  ResourceGroupName: String!
  Subscription: AppSubscription!
}

# Master inventory for both on-prem and cloud assets.
type Resource @table(key: "ResourceID") {
  ResourceID: UUID! @default(expr: "uuidV4()")
  ResourceName: String!
  ResourceType: String!
  # Where the resource lives (e.g., Azure, OnPrem, AWS).
  Source: String!
  # The unique ID from Azure Resource Manager (ARM). Null for on-prem.
  AzureResourceID: String
  Subscription: AppSubscription!
  ResourceGroup: ResourceGroup!
  # Azure region or on-prem datacenter name.
  Location: String
  # Flexible field to store specific details like VM size, OS, IP addresses, etc.
  Configuration: String
  # Stores key-value tags from the cloud provider or internal systems.
  Tags: String
}

# The five pillars of the Well-Architected Framework.
type WAFPillar @table(key: "PillarID") {
  PillarID: Int!
  PillarName: String!
}

# Specific best practices or "controls" within each WAF pillar.
type WAFControl @table(key: "ControlID") {
  ControlID: UUID! @default(expr: "uuidV4()")
  Pillar: WAFPillar!
  ControlName: String! @col(dataType: "varchar(255)")
  Description: String!
  Severity: String! # High, Medium, Low
}

# Junction table connecting resources to controls, tracking compliance status.
type ResourceControlStatus @table(key: "StatusID") {
  StatusID: UUID! @default(expr: "uuidV4()")
  Resource: Resource!
  Control: WAFControl!
  # Compliant, NonCompliant, NotApplicable.
  ComplianceStatus: String!
  LastChecked: Timestamp! @default(expr: "request.time")
  Notes: String
}

# Stores performance and cost metrics for resources in a long-form format.
type Metric @table(key: "MetricID") {
  MetricID: String! # Using String for BIGINT equivalent
  Resource: Resource!
  # Name of the metric (e.g., CPU_Percentage, Memory_Used_Bytes, Cost_USD).
  MetricName: String!
  MetricValue: Float!
  Timestamp: Timestamp!
  # The unit of measurement (e.g., Percent, Bytes, Count).
  Unit: String!
}

# Tracks the migration journey of an on-prem resource to its cloud counterpart.
type Migration @table(key: "MigrationID") {
  MigrationID: UUID! @default(expr: "uuidV4()")
  OnPremResource: Resource!
  CloudResource: Resource # Can be null initially.
  # Planned, InProgress, Completed, Failed.
  MigrationStatus: String!
  PlannedDate: Date
  CompletedDate: Date
}
